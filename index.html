<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Cellularium - Redesign</title>
    <style>
        :root {
            --bg: #101014;
            --panel: #1b1b22;
            --panel-border: #30363d;
            --text: #dce0e6;
            --text-dim: #8b949e;
            --accent: #58a6ff;
            --accent-green: #2ea043;
            --danger: #da3633;
            --control-h: 60px;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0; font-family: 'Segoe UI', system-ui, sans-serif;
            background: var(--bg); color: var(--text);
            display: flex; flex-direction: column;
            height: 100vh; overflow: hidden;
        }

        /* --- UI COMPONENTS --- */
        select, input[type="range"] {
            background: #0d1117; border: 1px solid var(--panel-border);
            color: white; border-radius: 6px; height: 36px; padding: 0 8px;
            font-size: 14px; width: 100%;
        }
        select:focus, input:focus { outline: 2px solid var(--accent); border-color: transparent; }

        label { font-size: 0.75rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 0.5px; display: block; margin-bottom: 4px; }

        button {
            border: 1px solid var(--panel-border); border-radius: 6px;
            background: #21262d; color: var(--text); cursor: pointer;
            font-weight: 600; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 8px;
            height: 40px;
        }
        button:active { transform: scale(0.96); }
        button.active { background: var(--accent); color: #0d1117; border-color: var(--accent); }
        button.danger { color: var(--danger); border-color: rgba(218, 54, 51, 0.3); }
        button.danger:hover { background: var(--danger); color: white; }

        /* --- TOP HEADER (Configuration) --- */
        #top-bar {
            background: var(--panel); border-bottom: 1px solid var(--panel-border);
            padding: 10px 15px; display: flex; flex-direction: column; gap: 10px;
            z-index: 10; flex-shrink: 0;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .row-group {
            display: flex; gap: 15px; align-items: flex-end; flex-wrap: wrap;
        }
        .control-item { flex: 1; min-width: 140px; }

        /* Style sp√©cifique pour le groupe bruit (slider + d√©) */
        .noise-group { display: flex; gap: 5px; }
        .noise-group input { flex: 1; }
        .noise-group button { width: 40px; height: 36px; margin: 0; }

        /* Infos & Graph overlay (Collapsible style to save space) */
        #stats-bar {
            display: flex; gap: 15px; align-items: center; justify-content: space-between;
            font-size: 0.85rem; color: var(--text-dim);
            padding: 5px 0; border-top: 1px solid #30363d; margin-top: 5px;
        }
        #graph-mini-container {
            width: 100px; height: 30px; background: #000; border: 1px solid #333; position: relative;
        }

        /* --- MAIN VIEWPORT (Grille) --- */
        #viewport {
            flex: 1; position: relative; background: #050505;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; touch-action: none;
        }
        
        #canvas-wrapper {
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
            border: 1px solid #333;
            background: #000;
        }
        canvas#grid { display: block; image-rendering: pixelated; }

        /* HUD flottant pour l'info r√®gle */
        .hud-rule-info {
            position: absolute; top: 10px; left: 50%; transform: translateX(-50%);
            background: rgba(27, 27, 34, 0.85); backdrop-filter: blur(4px);
            padding: 6px 12px; border-radius: 20px; border: 1px solid var(--panel-border);
            font-size: 0.8rem; pointer-events: none; text-align: center;
            max-width: 90%; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }

        /* --- BOTTOM BAR (Contr√¥les Playback) --- */
        #bottom-bar {
            background: var(--panel); border-top: 1px solid var(--panel-border);
            padding: 10px 15px; flex-shrink: 0; z-index: 10;
            padding-bottom: max(10px, env(safe-area-inset-bottom));
        }

        .playback-controls {
            display: flex; gap: 10px; align-items: center; margin-bottom: 10px;
        }
        .playback-controls button { flex: 1; height: 44px; font-size: 1rem; }
        
        .speed-control {
            display: flex; align-items: center; gap: 10px;
            background: rgba(0,0,0,0.2); padding: 5px 10px; border-radius: 8px;
        }
        .speed-control input { margin: 0; height: 24px; }

        /* --- RESPONSIVE --- */
        @media (max-width: 600px) {
            h1 { display: none; } /* On cache le titre sur mobile pour gagner de la place */
            .row-group { gap: 8px; }
            .control-item { min-width: 45%; } /* 2 items par ligne sur mobile */
            
            /* R√©organiser pour que zoom/bruit soient compacts */
            #top-bar { padding: 8px; }
            select { font-size: 16px; } /* Evite le zoom auto sur iOS */
        }
    </style>
</head>
<body>

    <div id="top-bar">
        <div class="row-group">
            <div class="control-item">
                <label>1. R√®gle de l'Univers</label>
                <select id="select-rule"></select>
            </div>
            <div class="control-item">
                <label>2. Ins√©rer Forme</label>
                <select id="select-pattern">
                    <option value="">-- Choisir --</option>
                </select>
            </div>
        </div>

        <div class="row-group" style="margin-top:5px;">
            <div class="control-item">
                <label>3. Zoom / Taille Grille</label>
                <input type="range" id="range-zoom" min="2" max="40" value="10">
            </div>
            <div class="control-item">
                <label>4. Bruit Al√©atoire</label>
                <div class="noise-group">
                    <input type="range" id="range-density" min="5" max="50" value="20">
                    <button id="btn-random">üé≤</button>
                </div>
            </div>
        </div>

        <div id="stats-bar">
            <div>G√©n: <strong id="lbl-gen" style="color:var(--accent)">0</strong></div>
            <div>Pop: <strong id="lbl-pop">0</strong></div>
            <div style="display:flex; align-items:center; gap:5px;">
                <label style="margin:0; cursor:pointer;"><input type="checkbox" id="chk-wrap" checked> Monde Torique</label>
            </div>
            <div id="graph-mini-container">
                <canvas id="population-graph" width="100" height="30"></canvas>
            </div>
        </div>
    </div>

    <div id="viewport">
        <div class="hud-rule-info">
            <span id="info-title" style="color:var(--accent); font-weight:bold;">Life</span> : 
            <span id="info-desc-short" style="color:var(--text-dim)">Classic</span>
        </div>
        <div id="canvas-wrapper">
            <canvas id="grid"></canvas>
        </div>
    </div>

    <div id="bottom-bar">
        <div class="playback-controls">
            <button id="btn-play">‚ñ∂ Lecture</button>
            <button id="btn-step">‚èØ Pas</button>
            <button id="btn-clear" class="danger">üóë Reset</button>
        </div>

        <div class="speed-control">
            <label style="margin:0; white-space:nowrap;">üê¢ Vitesse</label>
            <input type="range" id="range-speed" min="1" max="60" value="30" style="flex:1;">
            <label style="margin:0;">üêá</label>
        </div>
    </div>

<script>
/* --- CONFIGURATION ET DONN√âES (Identique √† l'original) --- */

const RULES = {
    "life": { name: "Conway's Life", type: "life", states: 2, B: [3], S: [2,3], colors: ['#000000', '#58a6ff'], desc: "Na√Æt avec 3, survit avec 2 ou 3." },
    "highlife": { name: "HighLife", type: "life", states: 2, B: [3,6], S: [2,3], colors: ['#000000', '#d2a8ff'], desc: "Na√Æt avec 3 ou 6. Poss√®de le Replicator." },
    "daynight": { name: "Day & Night", type: "life", states: 2, B: [3,6,7,8], S: [3,4,6,7,8], colors: ['#000000', '#ffa657'], desc: "Sym√©trique et complexe." },
    "morley": { name: "Morley", type: "life", states: 2, B: [3,6,8], S: [2,4,5], colors: ['#000000', '#ff7b72'], desc: "G√©n√®re beaucoup de vaisseaux." },
    "brain": { name: "Brian's Brain", type: "gens", states: 3, B: [2], S: [], colors: ['#000000', '#7ee787', '#ff7b72'], desc: "3 √©tats : Pr√™t > Actif > R√©fractaire." },
    "starwars": { name: "Star Wars", type: "gens", states: 4, B: [2], S: [3,4,5], colors: ['#000000', '#79c0ff', '#1f6feb', '#ff7b72'], desc: "Flottes de vaisseaux." },
    "wireworld": { name: "WireWorld", type: "wire", states: 4, colors: ['#101010', '#ffffff', '#ff5555', '#ffcc00'], desc: "Simulation √©lectronique." }
};

const PATTERNS = [
    { id: "glider", name: "Planeur", cat: "Classique", rule: "life", coords: [[1,0],[2,1],[0,2],[1,2],[2,2]] },
    { id: "pentadecathlon", name: "Pentadecathlon", cat: "Classique", rule: "life", coords: [[0,0],[1,0], [3,0],[4,0],[5,0],[6,0], [8,0],[9,0], [2,-1],[7,-1], [2,1],[7,1]] },
    { id: "pulsar", name: "Pulsar", cat: "Classique", rule: "life", coords: [[2,0],[3,0],[4,0],[8,0],[9,0],[10,0], [0,2],[5,2],[7,2],[12,2], [0,3],[5,3],[7,3],[12,3], [0,4],[5,4],[7,4],[12,4], [2,5],[3,5],[4,5],[8,5],[9,5],[10,5]] },
    { id: "r-pentomino", name: "R-Pentomino", cat: "Chaos", rule: "life", coords: [[1,0],[2,0],[0,1],[1,1],[1,2]] },
    { id: "diehard", name: "Diehard", cat: "Chaos", rule: "life", coords: [[6,0], [0,1],[1,1], [1,2],[5,2],[6,2],[7,2]] },
    { id: "acorn", name: "Acorn", cat: "Chaos", rule: "life", coords: [[1,0], [3,1], [0,2],[1,2], [4,2],[5,2],[6,2]] },
    { id: "gosper", name: "Gosper Gun", cat: "Complexe", rule: "life", coords: [[24,0],[22,1],[24,1],[12,2],[13,2],[20,2],[21,2],[34,2],[35,2],[11,3],[15,3],[20,3],[21,3],[34,3],[35,3],[0,4],[1,4],[10,4],[16,4],[20,4],[21,4],[0,5],[1,5],[10,5],[14,5],[16,5],[17,5],[22,5],[24,5],[10,6],[16,6],[24,6],[11,7],[15,7],[12,8],[13,8]] },
    { id: "replicator", name: "Replicator", cat: "HighLife", rule: "highlife", coords: [[2,0],[3,0],[4,0], [1,1],[4,1], [0,2],[4,2], [0,3],[3,3], [0,4],[1,4],[2,4]] },
    { id: "butterfly", name: "Butterfly", cat: "Generations", rule: "brain", coords: [[1,0,1],[2,0,2], [0,1,2],[1,1,2],[2,1,1],[3,1,2], [1,2,2],[2,2,2],[3,2,1]] },
    { id: "logic", name: "Diode", cat: "√âlectronique", rule: "wireworld", coords: [[0,5,3],[1,5,3],[2,5,3],[3,5,3],[4,5,3],[5,5,3],[6,5,3],[7,5,3],[8,5,3],[9,5,3],[10,5,3],[1,5,1],[0,5,2],[6,4,3],[7,4,3], [6,6,3],[7,6,3], [8,5,3]] }
];

/* --- MOTEUR --- */
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d', { alpha: false });
const wrapper = document.getElementById('canvas-wrapper');

let config = { cellSize: 10, speed: 30, wrap: true, cols: 0, rows: 0 }; // Default zoom 10
let grid = [], nextGrid = [];
let isPlaying = false, animationId, lastTime = 0, generation = 0;
let currentRule = RULES.life;

// Graph
const graphCanvas = document.getElementById('population-graph');
const graphCtx = graphCanvas.getContext('2d');
let populationHistory = [];
const MAX_HISTORY_POINTS = 50; // Graphique plus court pour le design compact

// Init UI
const ruleSelect = document.getElementById('select-rule');
Object.keys(RULES).forEach(key => {
    let opt = document.createElement('option');
    opt.value = key; opt.textContent = RULES[key].name;
    ruleSelect.appendChild(opt);
});

const patSelect = document.getElementById('select-pattern');
let lastCat = "";
PATTERNS.forEach(p => {
    if(p.cat !== lastCat) {
        let g = document.createElement('optgroup'); g.label = p.cat; patSelect.appendChild(g); lastCat = p.cat;
    }
    let opt = document.createElement('option'); opt.value = p.id; opt.textContent = p.name;
    patSelect.lastChild.appendChild(opt);
});

/* --- LOGIQUE --- */
function getIdx(x, y) {
    if (config.wrap) { x = (x + config.cols) % config.cols; y = (y + config.rows) % config.rows; }
    else if (x < 0 || x >= config.cols || y < 0 || y >= config.rows) return -1;
    return y * config.cols + x;
}

function countNeighbors(x, y, type) {
    let n = 0;
    for(let dy=-1; dy<=1; dy++) {
        for(let dx=-1; dx<=1; dx++) {
            if(!dx && !dy) continue;
            const idx = getIdx(x+dx, y+dy);
            if(idx === -1) continue;
            const val = grid[idx];
            if ((type === 'life' || type === 'gens' || type === 'wire') && val === 1) n++;
        }
    }
    return n;
}

function update() {
    let active = 0;
    for (let y=0; y<config.rows; y++) {
        for (let x=0; x<config.cols; x++) {
            const idx = y * config.cols + x;
            const s = grid[idx];
            let ns = 0;

            if (currentRule.type === 'life') {
                const n = countNeighbors(x, y, 'life');
                if (s === 1) ns = currentRule.S.includes(n) ? 1 : 0;
                else ns = currentRule.B.includes(n) ? 1 : 0;
            } else if (currentRule.type === 'gens') {
                if (s === 0) ns = currentRule.B.includes(countNeighbors(x, y, 'gens')) ? 1 : 0;
                else if (s === 1) ns = currentRule.S.includes(countNeighbors(x, y, 'gens')) ? 1 : 2;
                else { ns = s + 1; if (ns >= currentRule.states) ns = 0; }
            } else if (currentRule.type === 'wire') {
                if (s === 1) ns = 2; else if (s === 2) ns = 3;
                else if (s === 3) {
                    const n = countNeighbors(x, y, 'wire');
                    ns = (n === 1 || n === 2) ? 1 : 3;
                } else ns = 0;
            }

            nextGrid[idx] = ns;
            if(ns === 1) active++;
        }
    }
    [grid, nextGrid] = [nextGrid, grid];
    generation++;
    document.getElementById('lbl-gen').innerText = generation;
    document.getElementById('lbl-pop').innerText = active;
    
    populationHistory.push(active);
    if (populationHistory.length > MAX_HISTORY_POINTS) populationHistory.shift();
    updateGraph();
}

/* --- RENDU --- */
function draw() {
    ctx.fillStyle = currentRule.colors[0];
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const sz = config.cellSize;
    const pad = sz > 4 ? 1 : 0; 
    for(let y=0; y<config.rows; y++) {
        for(let x=0; x<config.cols; x++) {
            const s = grid[y*config.cols + x];
            if (s > 0) {
                ctx.fillStyle = currentRule.colors[s] || '#fff';
                ctx.fillRect(x*sz, y*sz, sz-pad, sz-pad);
            }
        }
    }
}

function updateGraph() {
    // Version compacte du graphique
    const w = graphCanvas.width;
    const h = graphCanvas.height;
    graphCtx.clearRect(0, 0, w, h);
    if(populationHistory.length < 2) return;

    let max = Math.max(...populationHistory, 10);
    let min = Math.min(...populationHistory);
    let range = max - min || 1;

    graphCtx.beginPath();
    graphCtx.strokeStyle = '#2ea043';
    graphCtx.lineWidth = 1;

    const stepX = w / (MAX_HISTORY_POINTS - 1);
    for(let i=0; i<populationHistory.length; i++) {
        const y = h - ((populationHistory[i] - min) / range) * h;
        if(i===0) graphCtx.moveTo(i*stepX, y); else graphCtx.lineTo(i*stepX, y);
    }
    graphCtx.stroke();
}

function resize() {
    const rect = document.getElementById('viewport').getBoundingClientRect();
    // On garde une marge pour l'esth√©tique
    const w = Math.floor(rect.width - 20);
    const h = Math.floor(rect.height - 20);
    
    canvas.width = w; canvas.height = h;
    wrapper.style.width = w+"px"; wrapper.style.height = h+"px";

    config.cols = Math.ceil(w / config.cellSize);
    config.rows = Math.ceil(h / config.cellSize);
    
    // On essaie de pr√©server le centre si possible, sinon reset
    grid = new Uint8Array(config.cols * config.rows);
    nextGrid = new Uint8Array(config.cols * config.rows);
    
    // Reset complet pour √©viter les bugs d'affichage
    generation = 0; populationHistory = [];
    draw();
}

function loop(t) {
    if(isPlaying && (t - lastTime > 1000/config.speed)) {
        update();
        draw();
        lastTime = t;
    }
    animationId = requestAnimationFrame(loop);
}

/* --- EVENTS --- */
ruleSelect.addEventListener('change', (e) => {
    currentRule = RULES[e.target.value];
    document.getElementById('info-title').innerText = currentRule.name;
    document.getElementById('info-desc-short').innerText = currentRule.desc;
    
    grid.fill(0); generation = 0; populationHistory = [];
    document.getElementById('lbl-gen').innerText = '0';
    document.getElementById('lbl-pop').innerText = '0';
    draw();
});

patSelect.addEventListener('change', (e) => {
    const pid = e.target.value;
    if(!pid) return;
    const p = PATTERNS.find(x => x.id === pid);
    if(p.rule && p.rule !== ruleSelect.value) {
        ruleSelect.value = p.rule;
        ruleSelect.dispatchEvent(new Event('change'));
    }
    grid.fill(0); generation = 0; populationHistory = [];
    
    const cx = Math.floor(config.cols/2);
    const cy = Math.floor(config.rows/2);
    p.coords.forEach(([dx, dy, st]) => {
        let idx = getIdx(cx+dx-5, cy+dy-5); 
        if(idx !== -1) grid[idx] = st || 1;
    });
    draw();
    patSelect.value = "";
});

// Interactions Souris / Touch
let isDown = false;
const handleStart = () => isDown = true;
const handleEnd = () => isDown = false;
const handleMove = (e) => { 
    if(!isDown) return;
    e.preventDefault(); // Emp√™che le scroll sur mobile
    paint(e); 
};

canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('touchstart', handleStart, {passive: false});
window.addEventListener('mouseup', handleEnd);
window.addEventListener('touchend', handleEnd);

canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('touchmove', (e) => {
    if(isDown) {
        // Touch events have different coords logic
        const t = e.touches[0];
        paint({ clientX: t.clientX, clientY: t.clientY });
    }
}, {passive: false});
canvas.addEventListener('click', paint);

function paint(e) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / config.cellSize);
    const y = Math.floor((e.clientY - rect.top) / config.cellSize);
    const idx = getIdx(x, y);
    if(idx !== -1) {
        grid[idx] = (grid[idx] === 0) ? (currentRule.type === 'wire' ? 3 : 1) : 0;
        draw();
    }
}

// Contr√¥les
document.getElementById('btn-play').onclick = function() {
    isPlaying = !isPlaying;
    this.textContent = isPlaying ? "‚è∏ Pause" : "‚ñ∂ Lecture";
    this.classList.toggle('active');
};
document.getElementById('btn-step').onclick = () => { update(); draw(); };
document.getElementById('btn-clear').onclick = () => { 
    grid.fill(0); generation = 0; populationHistory = []; 
    document.getElementById('lbl-gen').innerText = '0';
    document.getElementById('lbl-pop').innerText = '0';
    draw(); updateGraph();
};
document.getElementById('btn-random').onclick = () => {
    const d = document.getElementById('range-density').value / 100;
    for(let i=0; i<grid.length; i++) {
        if(currentRule.type === 'wire') grid[i] = Math.random() < d ? 3 : 0; 
        else grid[i] = Math.random() < d ? 1 : 0;
    }
    generation = 0; draw();
};
document.getElementById('range-speed').oninput = (e) => config.speed = e.target.value;
document.getElementById('range-zoom').oninput = (e) => { config.cellSize = parseInt(e.target.value); resize(); };
document.getElementById('chk-wrap').onchange = (e) => config.wrap = e.target.checked;

// Init
window.addEventListener('resize', () => { resize(); });
resize();
ruleSelect.value = "life"; ruleSelect.dispatchEvent(new Event('change'));
loop(0);

</script>
</body>
</html>
