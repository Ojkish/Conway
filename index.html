<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L'Univers des Automates Cellulaires</title>
    <style>
        :root {
            --bg: #101014;
            --panel: #1b1b22;
            --text: #dce0e6;
            --text-dim: #8b949e;
            --accent: #58a6ff;
            --accent-hover: #79c0ff;
            --accent-green: #2ea043;
            --border: #30363d;
            --danger: #f85149;
        }
        body {
            margin: 0; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg); color: var(--text);
            display: flex; height: 100vh; overflow: hidden;
        }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 380px; background: var(--panel);
            border-right: 1px solid var(--border);
            display: flex; flex-direction: column;
            box-shadow: 4px 0 20px rgba(0,0,0,0.4);
            z-index: 10;
        }
        .scroll-content { padding: 20px; overflow-y: auto; flex: 1; }

        h1 { color: var(--accent); margin: 0 0 5px 0; font-size: 1.5rem; letter-spacing: -0.5px; }
        .subtitle { color: var(--text-dim); font-size: 0.85rem; margin-bottom: 20px; display: block; }
        
        h2 { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 1px; color: var(--text-dim); margin-top: 25px; border-bottom: 1px solid var(--border); padding-bottom: 5px; }

        /* Controls */
        .btn-row { display: flex; gap: 8px; margin-bottom: 10px; }
        button {
            flex: 1; padding: 10px; border: 1px solid var(--border); border-radius: 6px;
            background: #21262d; color: var(--text); cursor: pointer; font-weight: 600;
            transition: all 0.2s;
        }
        button:hover { background: #30363d; border-color: #8b949e; }
        button.active { background: var(--accent); color: #0d1117; border-color: var(--accent); }
        button.danger:hover { background: var(--danger); color: white; border-color: var(--danger); }

        select, input[type="range"] {
            width: 100%; padding: 8px; margin-bottom: 8px;
            background: #0d1117; border: 1px solid var(--border); color: white; border-radius: 4px;
        }

        /* Info Box */
        #info-panel {
            background: #161b22; padding: 15px; border-radius: 6px;
            border-left: 4px solid var(--accent); margin-top: 15px;
        }
        #info-title { font-weight: bold; color: var(--accent); display: block; margin-bottom: 5px; }
        #info-desc { font-size: 0.85rem; color: var(--text-dim); line-height: 1.4; }

        /* --- GRAPHICS --- */
        #graph-container {
            background: #000; border: 1px solid var(--border);
            height: 120px; width: 100%; position: relative;
            margin-top: 20px; border-radius: 6px; overflow: hidden;
        }
        #population-graph { display: block; width: 100%; height: 100%; }
        
        .graph-label {
            position: absolute; font-size: 10px; font-family: monospace; 
            color: var(--accent-green); pointer-events: none;
            text-shadow: 0 1px 2px black;
        }
        #lbl-max { top: 4px; left: 4px; }
        #lbl-min { bottom: 4px; left: 4px; }
        #lbl-cur { 
            top: 4px; right: 4px; 
            font-weight: bold; color: #fff; 
            background: rgba(0,0,0,0.6); padding: 2px 6px; border-radius: 4px;
        }

        /* --- VIEWPORT --- */
        #viewport {
            flex: 1; position: relative; background: #050505;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden;
        }
        
        /* Cadre d√©coratif autour du canvas */
        #canvas-wrapper {
            border: 1px solid #333;
            box-shadow: 0 0 50px rgba(0,0,0,0.7);
            background: #000;
        }
        canvas#grid { display: block; image-rendering: pixelated; }

        .hud {
            position: absolute; bottom: 20px; right: 20px;
            background: rgba(22, 27, 34, 0.9); padding: 10px 15px;
            border-radius: 20px; border: 1px solid var(--border);
            font-family: 'Courier New', monospace; font-size: 0.9rem;
            pointer-events: none; user-select: none;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <div class="scroll-content">
        <h1>Cellularium</h1>
        <span class="subtitle">Explorateur d'Automates Cellulaires</span>

        <div class="btn-row">
            <button id="btn-play">‚ñ∂ Lecture</button>
            <button id="btn-step">‚èØ Pas</button>
            <button id="btn-clear" class="danger">üóë Reset</button>
        </div>

        <h2>1. R√®gle de l'Univers</h2>
        <select id="select-rule"></select> 
        
        <h2>2. Ins√©rer une Forme</h2>
        <select id="select-pattern">
            <option value="">-- Choisir --</option>
        </select> 
        
        <div id="info-panel">
            <span id="info-title">Bienvenue</span>
            <span id="info-desc">S√©lectionnez une r√®gle et une structure pour commencer. Utilisez la souris pour dessiner ou modifier l'√©tat des cellules.</span>
        </div>

        <div id="graph-container">
            <canvas id="population-graph"></canvas>
            <div id="lbl-max" class="graph-label">Max: 0</div>
            <div id="lbl-min" class="graph-label">Min: 0</div>
            <div id="lbl-cur" class="graph-label">0</div>
        </div>

        <h2>Param√®tres</h2>
        <label>Vitesse de simulation</label>
        <input type="range" id="range-speed" min="1" max="60" value="30">
        
        <label>Zoom / Taille grille</label>
        <input type="range" id="range-zoom" min="2" max="40" value="8">

        <label>Bruit Al√©atoire</label>
        <div class="btn-row">
            <input type="range" id="range-density" min="5" max="50" value="20">
            <button id="btn-random" style="flex:0 0 40px;">üé≤</button>
        </div>

        <label style="display:flex; align-items:center; gap:10px; margin-top:10px; cursor:pointer;">
            <input type="checkbox" id="chk-wrap" checked>
            Monde Torique (Bords reli√©s)
        </label>
        <small style="color:#666;">Si d√©sactiv√©, le monde est fini et bord√© de murs.</small>
    </div>
</div>

<div id="viewport">
    <div id="canvas-wrapper">
        <canvas id="grid"></canvas>
    </div>
    <div class="hud">
        G√©n√©ration: <span id="lbl-gen" style="color:var(--accent)">0</span> | 
        Pop: <span id="lbl-pop">0</span>
    </div>
</div>

<script>
/* --- CONFIGURATION ET DONN√âES --- */

const RULES = {
    // --- FAMILLE LIFE (2 √©tats) ---
    "life": {
        name: "Conway's Life", type: "life", states: 2,
        B: [3], S: [2,3],
        colors: ['#000000', '#58a6ff'],
        desc: "<b>Le classique (1970).</b> <br>Une cellule na√Æt avec 3 voisins, survit avec 2 ou 3. Un √©quilibre parfait entre ordre et chaos, permettant des machines de Turing universelles."
    },
    "highlife": {
        name: "HighLife", type: "life", states: 2,
        B: [3,6], S: [2,3],
        colors: ['#000000', '#d2a8ff'],
        desc: "Similaire √† Life, mais une cellule na√Æt aussi avec 6 voisins. Connu pour son <b>Replicator</b>, une structure qui se clone elle-m√™me."
    },
    "daynight": {
        name: "Day & Night", type: "life", states: 2,
        B: [3,6,7,8], S: [3,4,6,7,8],
        colors: ['#000000', '#ffa657'],
        desc: "Une r√®gle sym√©trique : les zones mortes agissent comme les vivantes. Poss√®de des vaisseaux tr√®s complexes."
    },
    "morley": {
        name: "Morley (Move)", type: "life", states: 2,
        B: [3,6,8], S: [2,4,5],
        colors: ['#000000', '#ff7b72'],
        desc: "Connu pour ses vaisseaux appel√©s 'Ships' qui laissent beaucoup de d√©bris derri√®re eux."
    },
    
    // --- FAMILLE GENERATIONS (Multi-√©tats, vieillissement) ---
    "brain": {
        name: "Brian's Brain", type: "gens", states: 3,
        B: [2], S: [], 
        colors: ['#000000', '#7ee787', '#ff7b72'], // Vivant (Vert) -> Mourant (Rouge) -> Mort
        desc: "Imite les neurones. 3 √©tats : Pr√™t > Actif > R√©fractaire. Cr√©e de nombreux vaisseaux et oscillateurs."
    },
    "starwars": {
        name: "Star Wars", type: "gens", states: 4,
        B: [2], S: [3,4,5],
        colors: ['#000000', '#79c0ff', '#1f6feb', '#ff7b72'],
        desc: "R√®gle tr√®s vivante o√π les structures ressemblent √† des flottes de vaisseaux spatiaux en combat."
    },
    "belzhab": {
        name: "BelZhab Sediment", type: "gens", states: 8,
        B: [2,3], S: [2,3],
        colors: "gradient-blue",
        desc: "Une r√®gle qui tend √† laisser des structures cristallines fossilis√©es (s√©diments) derri√®re l'activit√©."
    },

    // --- FAMILLE ELECTRONIQUE ---
    "wireworld": {
        name: "WireWorld", type: "wire", states: 4,
        colors: ['#101010', '#ffffff', '#ff5555', '#ffcc00'], // Vide, T√™te, Queue, Cuivre
        desc: "Simulation √©lectronique. <br>Jaune = C√¢ble, Blanc = √âlectron (T√™te), Rouge = Queue.<br>Permet de cr√©er des portes logiques et des ordinateurs."
    }
};

const PATTERNS = [
    // --- CLASSICS ---
    { id: "glider", name: "Planeur (Glider)", cat: "Classique", rule: "life", desc: "Le plus petit vaisseau. Il se d√©place en diagonale.", coords: [[1,0],[2,1],[0,2],[1,2],[2,2]] },
    { id: "pentadecathlon", name: "Pentadecathlon", cat: "Classique", rule: "life", desc: "Oscillateur de p√©riode 15. D√©couvert par Conway en 1970.", coords: [[0,0],[1,0], /*GAP*/ [3,0],[4,0],[5,0],[6,0], /*GAP*/ [8,0],[9,0], [2,-1],[7,-1], [2,1],[7,1]] },
    { id: "pulsar", name: "Pulsar", cat: "Classique", rule: "life", desc: "Oscillateur de p√©riode 3 tr√®s commun.", coords: [[2,0],[3,0],[4,0],[8,0],[9,0],[10,0], [0,2],[5,2],[7,2],[12,2], [0,3],[5,3],[7,3],[12,3], [0,4],[5,4],[7,4],[12,4], [2,5],[3,5],[4,5],[8,5],[9,5],[10,5], /*Sym√©trie non compl√®te pour bri√®vet√©*/] },

    // --- MATHUSALEMS ---
    { id: "r-pentomino", name: "R-Pentomino", cat: "Chaos", rule: "life", desc: "Seulement 5 cellules, mais met 1103 g√©n√©rations √† se stabiliser. Le p√®re du chaos dans Life.", coords: [[1,0],[2,0],[0,1],[1,1],[1,2]] },
    { id: "diehard", name: "Diehard", cat: "Chaos", rule: "life", desc: "Dispara√Æt compl√®tement apr√®s 130 g√©n√©rations. Son nom signifie 'Dur √† cuire'.", coords: [[6,0], [0,1],[1,1], [1,2],[5,2],[6,2],[7,2]] },
    { id: "acorn", name: "Acorn (Gland)", cat: "Chaos", rule: "life", desc: "Produit 13 planeurs et dure 5206 g√©n√©rations.", coords: [[1,0], [3,1], [0,2],[1,2], [4,2],[5,2],[6,2]] },

    // --- COMPLEXE ---
    { id: "gosper", name: "Gosper Glider Gun", cat: "Canons & Vaisseaux", rule: "life", desc: "La premi√®re structure produisant des vaisseaux √† l'infini. Prouve que la population peut cro√Ætre ind√©finiment.", coords: [[24,0],[22,1],[24,1],[12,2],[13,2],[20,2],[21,2],[34,2],[35,2],[11,3],[15,3],[20,3],[21,3],[34,3],[35,3],[0,4],[1,4],[10,4],[16,4],[20,4],[21,4],[0,5],[1,5],[10,5],[14,5],[16,5],[17,5],[22,5],[24,5],[10,6],[16,6],[24,6],[11,7],[15,7],[12,8],[13,8]] },
    { id: "puffer1", name: "Puffer Train", cat: "Canons & Vaisseaux", rule: "life", desc: "Un vaisseau qui laisse une tra√Æn√©e de d√©bris derri√®re lui en avan√ßant.", coords: [[1,0],[2,0],[3,0],[10,0],[11,0],[12,0],[13,0], [0,1],[4,1],[9,1],[13,1], [4,2],[13,2], [0,3],[3,3],[9,3],[12,3]] },
    
    // --- VARIANTES ---
    { id: "replicator", name: "Le Replicator", cat: "HighLife", rule: "highlife", desc: "Sp√©cifique √† HighLife. Cette structure se copie elle-m√™me horizontalement tous les 12 pas.", coords: [[2,0],[3,0],[4,0], [1,1],[4,1], [0,2],[4,2], [0,3],[3,3], [0,4],[1,4],[2,4]] },
    { id: "rocket", name: "Rocket", cat: "Day & Night", rule: "daynight", desc: "Un vaisseau rapide sp√©cifique √† la r√®gle Day & Night.", coords: [[4,0], [0,1],[1,1],[2,1],[4,1], [0,2],[1,2],[2,2],[3,2], [4,3]] },

    // --- GENERATIONS ---
    { id: "butterfly", name: "Butterfly", cat: "Generations", rule: "brain", desc: "Brian's Brain. Ce vaisseau ressemble √† un papillon battant des ailes.", coords: [[1,0,1],[2,0,2], [0,1,2],[1,1,2],[2,1,1],[3,1,2], [1,2,2],[2,2,2],[3,2,1]] },
    { id: "meteor", name: "Meteor", cat: "Generations", rule: "starwars", desc: "Vaisseau typique de Star Wars laissant une tra√Æn√©e.", coords: [[0,0,1],[1,0,1],[2,0,1],[3,0,1], [0,1,1],[3,1,1], [0,2,1],[3,2,1], [1,3,1],[2,3,1]] },

    // --- WIREWORLD ---
    { id: "logic", name: "Diode & Signal", cat: "√âlectronique", rule: "wireworld", desc: "D√©monstration de WireWorld. Le signal (blanc/rouge) circule dans le fil (jaune) mais est bloqu√© par la diode.", coords: [
        [0,5,3],[1,5,3],[2,5,3],[3,5,3],[4,5,3],[5,5,3],[6,5,3],[7,5,3],[8,5,3],[9,5,3],[10,5,3],
        [1,5,1],[0,5,2],
        [6,4,3],[7,4,3], [6,6,3],[7,6,3], [8,5,3]
    ] }
];

/* --- MOTEUR --- */
const canvas = document.getElementById('grid');
const ctx = canvas.getContext('2d', { alpha: false });
const wrapper = document.getElementById('canvas-wrapper');

let config = {
    cellSize: 8,
    speed: 30,
    wrap: true,
    cols: 0, rows: 0
};

let grid = [];
let nextGrid = [];
let isPlaying = false;
let animationId;
let lastTime = 0;
let generation = 0;
let currentRule = RULES.life;

// Variables pour le graphique
const graphCanvas = document.getElementById('population-graph');
const graphCtx = graphCanvas.getContext('2d');
let populationHistory = [];
const MAX_HISTORY_POINTS = 200; 

// Variable de lissage du graphique
let smoothedMax = 10;
let smoothedMin = 0;

// Initialisation UI
const ruleSelect = document.getElementById('select-rule');
Object.keys(RULES).forEach(key => {
    let opt = document.createElement('option');
    opt.value = key; opt.textContent = RULES[key].name;
    ruleSelect.appendChild(opt);
});

const patSelect = document.getElementById('select-pattern');
let lastCat = "";
PATTERNS.forEach(p => {
    if(p.cat !== lastCat) {
        let g = document.createElement('optgroup'); g.label = p.cat; patSelect.appendChild(g); lastCat = p.cat;
    }
    let opt = document.createElement('option'); opt.value = p.id; opt.textContent = p.name;
    patSelect.lastChild.appendChild(opt);
});

// --- LOGIQUE ---

function getIdx(x, y) {
    if (config.wrap) {
        x = (x + config.cols) % config.cols;
        y = (y + config.rows) % config.rows;
    } else {
        if (x < 0 || x >= config.cols || y < 0 || y >= config.rows) return -1;
    }
    return y * config.cols + x;
}

function countNeighbors(x, y, type) {
    let n = 0;
    // Voisinage de Moore (8)
    for(let dy=-1; dy<=1; dy++) {
        for(let dx=-1; dx<=1; dx++) {
            if(!dx && !dy) continue;
            const idx = getIdx(x+dx, y+dy);
            if(idx === -1) continue;
            
            const val = grid[idx];
            if (type === 'life' || type === 'gens') {
                if (val === 1) n++;
            } else if (type === 'wire') {
                if (val === 1) n++; 
            }
        }
    }
    return n;
}

function update() {
    let active = 0;
    
    for (let y=0; y<config.rows; y++) {
        for (let x=0; x<config.cols; x++) {
            const idx = y * config.cols + x;
            const s = grid[idx];
            let ns = 0;

            if (currentRule.type === 'life') {
                const n = countNeighbors(x, y, 'life');
                if (s === 1) ns = currentRule.S.includes(n) ? 1 : 0;
                else ns = currentRule.B.includes(n) ? 1 : 0;
            
            } else if (currentRule.type === 'gens') {
                if (s === 0) {
                    const n = countNeighbors(x, y, 'gens');
                    ns = currentRule.B.includes(n) ? 1 : 0;
                } else if (s === 1) {
                    const n = countNeighbors(x, y, 'gens');
                    if (currentRule.S.includes(n)) ns = 1;
                    else ns = 2;
                } else {
                    ns = (s + 1);
                    if (ns >= currentRule.states) ns = 0;
                }
            
            } else if (currentRule.type === 'wire') {
                if (s === 1) ns = 2;
                else if (s === 2) ns = 3;
                else if (s === 3) {
                    const n = countNeighbors(x, y, 'wire');
                    ns = (n === 1 || n === 2) ? 1 : 3;
                } else ns = 0;
            }

            nextGrid[idx] = ns;
            if(ns === 1) active++;
        }
    }

    [grid, nextGrid] = [nextGrid, grid];
    generation++;
    document.getElementById('lbl-gen').innerText = generation;
    document.getElementById('lbl-pop').innerText = active;
    
    populationHistory.push(active);
    if (populationHistory.length > MAX_HISTORY_POINTS) {
        populationHistory.shift();
    }
    
    updateGraph();
}

// --- RENDU ---
function getColor(state, rule) {
    if(state === 0) return rule.colors[0];
    if(rule.colors === "gradient-blue") {
         return `hsl(210, 100%, ${50 + (state/rule.states)*40}%)`;
    }
    if(rule.colors[state]) return rule.colors[state];
    return '#fff';
}

function draw() {
    ctx.fillStyle = currentRule.colors[0];
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const sz = config.cellSize;
    const pad = sz > 4 ? 1 : 0; 

    for(let y=0; y<config.rows; y++) {
        for(let x=0; x<config.cols; x++) {
            const s = grid[y*config.cols + x];
            if (s > 0) {
                ctx.fillStyle = getColor(s, currentRule);
                ctx.fillRect(x*sz, y*sz, sz-pad, sz-pad);
            }
        }
    }
}

// --- GRAPHIQUE DE POPULATION (LISS√â) ---
function updateGraph() {
    const w = graphCanvas.width = graphCanvas.clientWidth;
    const h = graphCanvas.height = graphCanvas.clientHeight;
    
    graphCtx.clearRect(0, 0, w, h);

    if(populationHistory.length === 0) return;

    // 1. Calculer les cibles (vrai Max et vrai Min)
    let targetMax = Math.max(...populationHistory, 10);
    let targetMin = Math.min(...populationHistory);
    targetMax = targetMax * 1.1; // Padding haut

    // 2. Lissage (Interpolation lin√©aire)
    // On d√©place smoothedMax de 10% vers la cible √† chaque frame
    // Si la cible est BEAUCOUP plus grande (explosion de pop), on y va plus vite
    if (targetMax > smoothedMax) {
        smoothedMax += (targetMax - smoothedMax) * 0.2; // Mont√©e assez rapide
    } else {
        smoothedMax += (targetMax - smoothedMax) * 0.05; // Descente lente
    }
    
    smoothedMin += (targetMin - smoothedMin) * 0.1;

    // Mise √† jour des labels
    document.getElementById('lbl-max').innerText = "Max: " + Math.round(smoothedMax);
    document.getElementById('lbl-min').innerText = "Min: " + Math.round(smoothedMin);
    const curVal = populationHistory[populationHistory.length-1];
    document.getElementById('lbl-cur').innerText = curVal;

    // Dessin
    graphCtx.beginPath();
    graphCtx.strokeStyle = '#2ea043';
    graphCtx.lineWidth = 2;

    const stepX = w / (MAX_HISTORY_POINTS - 1);
    const range = smoothedMax - smoothedMin || 1;

    for(let i=0; i<populationHistory.length; i++) {
        const val = populationHistory[i];
        // Formule de projection Y avec le lissage
        const y = h - ((val - smoothedMin) / range) * h;
        const x = i * stepX;
        
        if(i===0) graphCtx.moveTo(x, y);
        else graphCtx.lineTo(x, y);
    }
    graphCtx.stroke();

    graphCtx.lineTo((populationHistory.length-1)*stepX, h);
    graphCtx.lineTo(0, h);
    graphCtx.fillStyle = 'rgba(46, 160, 67, 0.2)';
    graphCtx.fill();
}

// --- UTILS ---
function resize() {
    const rect = document.getElementById('viewport').getBoundingClientRect();
    const w = Math.floor(rect.width - 40);
    const h = Math.floor(rect.height - 40);
    
    canvas.width = w; canvas.height = h;
    wrapper.style.width = w+"px"; wrapper.style.height = h+"px";

    config.cols = Math.ceil(w / config.cellSize);
    config.rows = Math.ceil(h / config.cellSize);
    
    grid = new Uint8Array(config.cols * config.rows);
    nextGrid = new Uint8Array(config.cols * config.rows);
    generation = 0;
    
    // Reset graph
    populationHistory = [];
    smoothedMax = 10; // Reset scale
    updateGraph();
    
    draw();
}

function loop(t) {
    if(isPlaying && (t - lastTime > 1000/config.speed)) {
        update();
        draw();
        lastTime = t;
    }
    animationId = requestAnimationFrame(loop);
}

// --- EVENTS ---
ruleSelect.addEventListener('change', (e) => {
    currentRule = RULES[e.target.value];
    document.getElementById('info-title').textContent = currentRule.name;
    document.getElementById('info-desc').innerHTML = currentRule.desc;
    grid.fill(0); 
    generation = 0; 
    document.getElementById('lbl-gen').innerText = '0';
    document.getElementById('lbl-pop').innerText = '0';
    populationHistory = []; 
    smoothedMax = 10;
    updateGraph();
    draw();
});

patSelect.addEventListener('change', (e) => {
    const pid = e.target.value;
    if(!pid) return;
    const p = PATTERNS.find(x => x.id === pid);
    
    if(p.rule && p.rule !== ruleSelect.value) {
        ruleSelect.value = p.rule;
        ruleSelect.dispatchEvent(new Event('change'));
    }

    document.getElementById('info-title').textContent = p.name;
    document.getElementById('info-desc').textContent = p.desc;

    grid.fill(0); 
    generation = 0; 
    document.getElementById('lbl-gen').innerText = '0';
    document.getElementById('lbl-pop').innerText = '0';
    populationHistory = []; 
    smoothedMax = 10;
    updateGraph();

    const cx = Math.floor(config.cols/2);
    const cy = Math.floor(config.rows/2);
    
    p.coords.forEach(([dx, dy, st]) => {
        let idx = getIdx(cx+dx-5, cy+dy-5); 
        if(idx !== -1) grid[idx] = st || 1;
    });
    draw();
    patSelect.value = "";
});

// Mouse Painting
let isDown = false;
canvas.addEventListener('mousedown', () => isDown = true);
window.addEventListener('mouseup', () => isDown = false);
canvas.addEventListener('mousemove', (e) => { if(isDown) paint(e); });
canvas.addEventListener('click', (e) => paint(e));

function paint(e) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / config.cellSize);
    const y = Math.floor((e.clientY - rect.top) / config.cellSize);
    const idx = getIdx(x, y);
    if(idx !== -1) {
        if(currentRule.type === 'wire') {
            grid[idx] = (grid[idx] === 3) ? 0 : 3; 
        } else {
            grid[idx] = (grid[idx] === 1) ? 0 : 1; 
        }
        draw();
    }
}

// UI Buttons
document.getElementById('btn-play').onclick = function() {
    isPlaying = !isPlaying;
    this.textContent = isPlaying ? "‚è∏ Pause" : "‚ñ∂ Lecture";
    this.classList.toggle('active');
};
document.getElementById('btn-step').onclick = () => { update(); draw(); };
document.getElementById('btn-clear').onclick = () => { 
    grid.fill(0); 
    generation = 0; 
    document.getElementById('lbl-gen').innerText = '0';
    document.getElementById('lbl-pop').innerText = '0';
    populationHistory = []; 
    smoothedMax = 10;
    updateGraph();
    draw(); 
};
document.getElementById('btn-random').onclick = () => {
    const d = document.getElementById('range-density').value / 100;
    for(let i=0; i<grid.length; i++) {
        if(currentRule.type === 'wire') {
             grid[i] = Math.random() < d ? 3 : 0; 
             if(grid[i] === 3 && Math.random() < 0.05) grid[i] = 1; 
        } else {
            grid[i] = Math.random() < d ? 1 : 0;
        }
    }
    generation = 0; 
    document.getElementById('lbl-gen').innerText = '0';
    document.getElementById('lbl-pop').innerText = '0';
    populationHistory = []; 
    smoothedMax = 10;
    updateGraph();
    draw();
};
document.getElementById('range-speed').oninput = (e) => config.speed = e.target.value;
document.getElementById('range-zoom').oninput = (e) => { config.cellSize = parseInt(e.target.value); resize(); };
document.getElementById('chk-wrap').onchange = (e) => config.wrap = e.target.checked;

// Start
window.addEventListener('resize', resize);
resize();
ruleSelect.value = "life"; ruleSelect.dispatchEvent(new Event('change'));
loop(0);

</script>
</body>
</html>